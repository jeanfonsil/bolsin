// =========================================================================
// ARQUIVO COMPLETO: src/app/api/download/route.ts
// =========================================================================

import { NextRequest, NextResponse } from 'next/server'
import { MonitoringService } from '@/lib/monitoring/monitoring'
import { categorizeTransactions } from '@/lib/ai/categorization'
import { CSVParser } from '@/lib/parsers/csv-parser'
import { getFileStore } from '@/lib/server/file-store'

export const runtime = 'nodejs'

// Store em memÃ³ria
declare global {
  var fileStore: Map<string, {
    buffer: Buffer
    metadata: any
  }>
}

const fileStore = global.fileStore

export async function POST(request: NextRequest) {
  const monitoring = MonitoringService.getInstance()
  const fileStore = getFileStore()
  
  console.log('ðŸ“¥ Download API iniciada...')
  
  try {
    const { fileId } = await request.json()
    
    if (!fileId) {
      return NextResponse.json(
        { error: 'ID do arquivo Ã© obrigatÃ³rio' },
        { status: 400 }
      )
    }

    console.log(`ðŸ” Preparando download para: ${fileId}`)
    
    monitoring.startProcess(fileId, 'download', {
      timestamp: new Date().toISOString()
    })

    // Buscar arquivo no store
    const fileData = fileStore.get(fileId)
    
    if (!fileData || fileData.metadata?.fileType !== 'csv') {
      monitoring.errorProcess(fileId, 'download', 'Arquivo nÃ£o encontrado ou tipo invÃ¡lido', {
        errorType: 'file_not_found',
        hasFile: !!fileData,
        fileType: fileData?.metadata?.fileType || 'unknown'
      })
      
      return NextResponse.json({
        success: false,
        error: 'Arquivo nÃ£o encontrado ou nÃ£o processado',
        suggestion: 'Execute upload e processamento primeiro'
      }, { status: 404 })
    }

    // Reprocessar o arquivo para download
    console.log('ðŸ”„ Reprocessando arquivo para download...')
    
    const csvContent = decodeBuffer(fileData.buffer)
    const parser = new CSVParser()
    const parseResult = await parser.parseCSV(csvContent)
    
    if (parseResult.transactions.length === 0) {
      monitoring.errorProcess(fileId, 'download', 'Nenhuma transaÃ§Ã£o encontrada no reprocessamento', {
        errorType: 'no_transactions_reprocess'
      })
      
      return NextResponse.json({
        success: false,
        error: 'Nenhuma transaÃ§Ã£o encontrada para download'
      }, { status: 422 })
    }

    // Categorizar novamente
    const descriptions = parseResult.transactions.map(t => t.description)
    const categorized = await categorizeTransactions(descriptions)
    
    // Formatar dados para download
    const formattedTransactions = parseResult.transactions.map((transaction, index) => ({
      'ID': index + 1,
      'Data': formatDateForDownload(transaction.date),
      'DescriÃ§Ã£o': cleanDescription(transaction.description),
      'Valor': formatCurrency(transaction.amount),
      'Tipo': transaction.type === 'debit' ? 'DÃ©bito' : 'CrÃ©dito',
      'Categoria': categorized[index]?.category || 'Outros',
      'ConfianÃ§a IA': formatConfidence(categorized[index]?.confidence || 0)
    }))

    console.log(`âœ… Download preparado: ${formattedTransactions.length} transaÃ§Ãµes`)

    monitoring.completeProcess(fileId, 'download', {
      transactionsDownloaded: formattedTransactions.length,
      fileName: fileData.metadata.originalName,
      source: 'reprocessed'
    })

    return NextResponse.json({
      success: true,
      data: {
        transactions: formattedTransactions,
        metadata: {
          totalTransactions: formattedTransactions.length,
          fileId,
          generatedAt: new Date().toISOString()
        }
      },
      source: 'reprocessed'
    })

  } catch (error) {
    console.error('âŒ Erro na API download:', error)
    
    const { fileId } = await request.json().catch(() => ({ fileId: 'unknown' }))
    monitoring.errorProcess(fileId, 'download', error instanceof Error ? error.message : 'Erro desconhecido', {
      errorType: 'download_error'
    })
    
    return NextResponse.json({
      success: false,
      error: 'Erro no download',
      message: error instanceof Error ? error.message : 'Erro desconhecido'
    }, { status: 500 })
  }
}

// FunÃ§Ãµes de formataÃ§Ã£o
function decodeBuffer(buffer: Buffer): string {
  const utf8Text = buffer.toString('utf-8')
  const hasUtf8Artifacts = /Ãƒ|Ã‚|ï¿½/.test(utf8Text)
  
  if (hasUtf8Artifacts) {
    const latin1Text = buffer.toString('latin1')
    const utf8ArtifactCount = (utf8Text.match(/Ãƒ|Ã‚|ï¿½/g) || []).length
    const latin1ArtifactCount = (latin1Text.match(/Ãƒ|Ã‚|ï¿½/g) || []).length
    return latin1ArtifactCount < utf8ArtifactCount ? latin1Text : utf8Text
  }
  
  return utf8Text
}

function formatDateForDownload(dateInput: any): string {
  if (!dateInput) return ''
  
  let date: Date
  
  if (typeof dateInput === 'string') {
    if (/^\d{4}-\d{2}-\d{2}$/.test(dateInput)) {
      const [year, month, day] = dateInput.split('-').map(Number)
      date = new Date(year, month - 1, day)
    } else {
      date = new Date(dateInput)
    }
  } else if (dateInput instanceof Date) {
    date = dateInput
  } else {
    return String(dateInput)
  }
  
  if (isNaN(date.getTime())) {
    return String(dateInput)
  }
  
  return date.toLocaleDateString('pt-BR')
}

function cleanDescription(description: string): string {
  if (!description) return ''
  
  return description
    .trim()
    .normalize('NFC')
    .replace(/\s+/g, ' ')
    .slice(0, 100)
}

function formatCurrency(amount: number): string {
  if (typeof amount !== 'number' || isNaN(amount)) {
    return 'R$ 0,00'
  }
  
  return `R$ ${Math.abs(amount).toLocaleString('pt-BR', { 
    minimumFractionDigits: 2,
    maximumFractionDigits: 2 
  })}`
}

function formatConfidence(confidence: number): string {
  if (typeof confidence !== 'number' || isNaN(confidence)) {
    return '0%'
  }
  
  return `${(confidence * 100).toFixed(1)}%`
}

export async function GET(request: NextRequest) {
  const { searchParams } = new URL(request.url)
  const fileId = searchParams.get('fileId')
  
  if (!fileId) {
    return NextResponse.json({
      error: 'fileId Ã© obrigatÃ³rio'
    }, { status: 400 })
  }

  return NextResponse.json({
    message: 'Use POST para baixar dados',
    endpoint: '/api/download',
    method: 'POST',
    body: { fileId }
  })
}
